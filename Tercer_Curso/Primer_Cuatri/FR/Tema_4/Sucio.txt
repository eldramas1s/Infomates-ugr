Cifrado simetrico = clave secreta

Cifrado asimetrico = clave distribuida

COnfidencialidad -> cidrado

Vamos a suponer que los distintos algoritmos de criptografia funcionan y nosotros veremos que los protocolos que usanla criptografía son los que funcionan bajo esa suposicion.


El algortimo de clave secreta es DES, antiguo pero se ha realizado
7
Usa claves de 56 bitsy haciendo 2⁵⁶ pruebas se puede sacar seguro -> es un algoritmo de sustitucion, es decir, si se da una entrada concreta, por mucho que se aplique la funcion conseguimos la misma salida.


Para arreglar la posibilidad de descifrado, hacemos que una salida de aplicarlo una vez se aplique en otra codificacion de otra entrada. Es decir la salida del estado anterior es la clave del estado posterior. Para decodificar tenemos que hacer el proceso inverso disponiendo solo de la clave inicial y la ultima palabra aplicada al codificar.

3Des lo que hace es aplicar distintas funciones de decodificado que suelen ser E=D⁻¹ entoncesaplicandolo tres veces conseguimos que se puedan hacer todos.


IDEA
-----------------

Es un tipo de cifrado simetrico:

- entra palara de 64 bits
- sale palabra de 64 bits
- CLave de 128 -> aumenta la complejidad en 2 ⁵⁶


Ambos se pueden ejecutar en tiempo real.

RSA
-------------------
Es un tipo de cifrado asimetrico

El interes es que es un algoritmo de clave publica.

Clave publica
-------------------

Cunado tenemos un algoritmo de calve publica disponemos de una clave publica y asociado a esto hay una clave privada que solo conoce el dueño(la publica todo el mundo). 

*Importante: si ciframos con la clave publica -> desciframos con la clave privada. Tambien se hace igual de forma inversa.*

Ademas hay una relacion univoca, es decir, para cada clave privada hay una clave publica y para cada clave publica hay una privada.

Esto proporviona mucha seguridad de autor de un delito pues no hay mas de un individuo con esa clave publica.

Volviendo a RSA:

Tomamos p,q numeros primos grandes para aportar dificultad, n=p*q, z=(p-1)(q-1), d primo relativo con z, así como un numero e tal que e*d mod z = 1. 

Como clave publica tomamos los numero (e,n) y como clave privada (d,n)


Para cifrar: 

- C=P^e mod n
- P=C^p mod n

donde C se refiere a como cifrar y P se refiere a como descifrar.

(Copiar ejemplo diap 15).


Autenticacion
-------------------------------------
------------------------------------

La autenticacion significa que le extremos sepa quién soy yo.

La forma mas sencilla para identificar es guardar en la base de datos las contraseñas de cada uno de los usuarios -> para autenticar mandar elk usuario y la contraseña(a clave).

Aunque es muy inseguro pues se puede interceptar la señal muy facil con una simple escucha hay muchos servicios que los usan como smtp, telnet... mas adelante se mejora la cosa y ssh sustituye a telnet.

Este proceso no es muy seguro y se hacen una serie de mejoras que resuelven el tema; vbamos a mandar algo que permite autenticar la clave sin mandarla:

- Reto-respuesta: dados dos usuarios A y B:
    1. A manda la quien es, la identidad.
    2. B manda un reto, es decir, un numero aleatorio cualquiera que genera B y conoce.
    3. A calcula algo con ese B y la clave, es decir, manda cifrado con la clave que comparten A y B ese reto. Y lo manda

De esta forma no se ha mandado la contraseña o clave pero B conoce la clave que tiene A, entonces, B cifra el reto y si cuoincide tenemos que B autentifica A.

de esta forma si no coincide se va a la mierda todo.

Podemos hacer la autenticación porque B conoce la clave de A y cifrando el reto con es clave debe coincidir, si no coincide no es A.

Problema: B sabe que es A pero A no sabe que es B; de la misma manera se hace el mismo proceso intercambiando los papeles.

Es importante que haya una doble autenticacion de ambos a ambos.

Problema(ataque por repeticion): un espía tomando muchos retos y resultados podemos concoer las respuestas y suplantar la identidad.

SOlocion: evitar la repeticion de retos -> por ejemplo reto=nºsecuencia(crecientes)+aleatorio(nonce)

Problema(ataque por reflexion): consiste en que el reto del servidor se reenvia antes de responder para recibir la respuesta del servidor y contestar ahora con la respuesta recibida del servidor.

Solucion: igual que ataque por repeticion.



Distribucion de claves a usuarios
-----------------------------------------

Es un problema habitual que hay que tener en cuenta. Para solucionar este problema se usa el intecambio de diffie-hellman:


Sean A, B dos entidades usaremos la operacion de modulo para intercambiar una clave de A con B:
    
    1. A clavula un numero n,g,x y manda n,g,g^xmod n 
    2. B recibe esto y calcula un numero y y manda g^y mod n

Ahora la clave que va a tener A es tomar (g^ymod n)^x=g^(x*y) mod n. B hace lo mismo con los datos que tiene y de esta dorma el resultado que coincide es la clave privada.

Es susceptible de ataque sde man-in-the-middle, de manera que el atacante hace lo mismo que haría B con un z estableciendo la clave privada que comparten A y atacante. Hace lo mismo con B con la misma z o ocon otra. De esta manera, el atacante tiene todo lo que necesita para descifrar un mensaje de A a B y de B a A sin que ninguna de las entidades se den cuenta de que el atacante está.


Fuciones Hash
----------------------------------------
----------------------------------------

Se usan para proporcionar integridad, de hecho sirven mucho para comprobar qu elos datos se han modificado o no.

Dada una entrada una funcion hash proporciona como salida un resumen o compendio; suelen tener un tamaño fijo de salida. Si meto algo grande y sale algo pequeño estoy perdiendo información, lo importante es que a partir del resumen es imposible conseguir el texto de entrada.


Supongamos que mandamso algo cifrado y ademas le sumamos el hash(p); podemos romperlo muy facil luego realmente haremos la concatenación de p con la clave privada entre dos entidades; de esta manera no podemosgenerar el hash entonces ahora si tenemos la comprobacion correcta.

A lo que se manda junto con el paquete que es hash(P|clave privada comun) lo llamaremos HMAC.

MD5
-----------

Dado un mensaje P de K digitos, necesitamos que se amultiplo de 512 bits, conlo que se mete un relleno:1000...0

Dividimos el mensaje en cjas de 512 bits y hacemo sconcatenacion de resumentes de esos paqteutes de 512 bits -> cada resumen son a 128 bits.
Cada salida anterior sirve de entrada para la siguiente caja.
La primera entrada es el mensaje y un mensaje de inicializacion

SHA
----------------

tiene distintas veriosnes, aqui tenemos SHA-1.

Dado un mensaje P de K bits, necesitamos que sea multiplo de 512 bits, con loq eu se mete un relleno si es necesario

La idea es la misma que MD5 con cajas que generan salidas de 160 bits.


Firma digital y certificados
--------------------------------------------
---------------------------------------------

una firma digital intenta ser un sustituto de una firma escrita -> esto nos permite garantizar el no repudio.

El no repudio se basa en usar una entidad en la que se confia.

Hay dos formas:
    
    1. Big brother -> usar una entidad en la que todos confian 
        Un big brother es una entidad que vigila a todos los usuarios, 
        
        Sean A y B dos entidades entr las que esta el BB (Big brother) de manera que para cada eaccion de A hacia B, B tiene una justificacion de que se ha realizado la accion por A.

        El BB es un servidor que tiene una base de datos donde se guardan las claves compartidas con cada uno de los usuarios.

        PAra que A mande un mensaje a B primero para a BB estando cifrado sabiendo primeor BB que es A quien habla. DE esta forma el BB puede descifrar. A manda:

        (A,KA(...)):
            
            - Identificador (A)
            - Cifrar con la clae K_A
            - B, es el detino
            - R_A resumen para dar la integridad
            - t, instante de tiempo
            - P, texto plano

        Ahora el BB reenvia el mensaje a B cifrado con la clave K_B y algo mas:
        K_B(A,R_A,t,P,K_BB(A,t,P))
        - K_BB es una clave que solo tiene el big brother y es un metodo de seguridad.
        De esta forma disponemos de una entidad donde todo el mundo se fía, el bb.


    2. Doble cifrado con certificados

        Si soy A que quiere mandar mensaje a B, cifrando con la clabe privada todo el mundo puede descifrarlo -> con esto consigo autenticacion(solo A lo ha podido cifrar). De la misma forma, si cifro con la clave publica de B -> conseguimos confidencialidad. Si cifro con mi clave publica -> no sirve para nada.

        Lo que vamos a hacer es cifrar con ambas claves publicas, por ejemplo, primero la clave privada y luego la publica conseguimso ambos aspectos en distinto orden pero al final se consigue.
        
        Cifrando con la clave privada conseguimos autenticacion.


        Esta composicion de cifrados no siempre sirve, de hecho solo sirve si A y B son los dueños de las claves corerspondientes, es decir:

        A->KpubA<->KprivA
        B->KpubB<->KprivB

        Por tanto necesitamos que alguien tenga constancia de que esto se cumple.

        Ese alguien es el certificado digital.


        POor tanto el doble cifrado proporciona no repudio si y solo si hay una entidad fiable que lo autorifique. En definitiva, tener un certificado digital.
    
CErtificado digital
------------------------

Contiene una identidad, la del usuario; su clave publica y mas datos que esta todo cifrado por la clave prvada de la autoridad de certificacion (firmado por la autoridad de certificacion). Esto solo lo ha podido firmar la autoridad de autentificacion.

Otro dato importante es el período de validez, puede caducar entonces puede dejar de funcionar.

¿Como conocemos nosotros las claves publicas de las autoridades de certificacion?

Cuando nactualizamos los programos que usan los ceritificados actualizamos estas claves publicas.


Un certificado no hace nada de las caracteristicas de seguridad si no se añade un procesamiento, es una herramienta.


Protocolos seguros
--------------------------
---------------------


PGP
---------------------------
Esun protocolo de aplicacion

Sea P el texto plano al que le generaremos un MD5(P)=R, es decir, el compendio; FD=KprivA(R) como firma digital.

Comprimir la firma digital junto al rexto plano (no sirve pa na, solo para mandar menos datos)

Ciframos la firma digital y el texto plano, es decir obtenemos C=IDEAk(Z) + KpubB dondek es una clave de  sesion que solo sirve para unmensaje.

Ademas el mensaje que mandamos lo codificamos con B64, es simplemente una codificacion y no un cifrado.

Todo esto es lo que s emanda a traves del canal y el receptor consigue C decodificando M y obtenemos la clave de sesion ademas de descifrar con la clave; en general hacemos el proceso inverso y comprobamos que sabiendo el texto plano en B que el resultado es correcto.
Tenemos confidencialidad, integridad, autenticacion porque hemos cifrado algo con la clave privada; pdría conseguir no repudio con el certificado digital usandolo.

SSl
----------------------------
A nivel de rtansporte



IPSec
---------

A nivel de red
