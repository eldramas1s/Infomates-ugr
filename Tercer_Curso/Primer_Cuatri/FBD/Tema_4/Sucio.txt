Arboles B+:

Consiste en un arbol equilibrado donde se define el orden maximo de punteros a los hijos puede tener un nodo.

Como en las hojas los nodos van enganchados unos conotros.  

Tablas organizadas por indice
--------------------------

En las hojas tienen directamente el registro completo -> la desventaja es qu elos registro de las hojas son mas grandes.


Indices clave invertida
-------------------------------

LA idea es permutar de alguna manera, cambiar el orden de los bytes(normalmente) de la clave donde se localiza un registro:
    - Ventaja: puede interesar que dos rgistros que puedan ser consecutivos puede no interesarnos que esten consecutivos para trabajar en el sisema.
    Si se espera que se acceda a dos elementos consecutivos por indice se hace esto para agilizar el problema.


Indices de mapa de bits
--------------------------

La idea es montar para cada bvlor del dominio actico de esa clave se monta un mampa de bits indicando que tuplas tienen ese valor.

Si hay un 1 en el mapa de bit -> esa tupla tiene el atrobuto que tiene ese mapa de bit.

No tiene sentido hacerlo con atributos que tomen pocos valores repetidos -> por ejemplono es util con claves primarias.




Parte tres
--------------------------
-------------------------
--------------------------

Buscamos sustituir la estructura de los indices por un algoritmo que me diga donde esta tal registro. (ejemplo hash...)

El campo por le que hagamos la busqueda tiene que ser unívoco.

Suele ser habitual qie los registros no mantengan directamente el orden -> perjudica las consultas por intervalos.


EL principal problema es que se producen colisiones -> mandan valores diferentes de la clave al mismo sitio.

Lo mas basico para gestionar colisiones es aaplicar una zon a de desbordamiento (listas) (hashing con listas).

Hay dos tecnicas:
-Hashing basico: En lugar de dirteccionar un sistio -> direccionamos a un "cubo" de registros -> de qui surge la idea de hash y listas. COn esto solo retrasamos las listas de desbordamiento -> ademas con un mal estudio del prosible desbordamiento puede que haya muchos mas huecos.

- Hashing dinamico. Monto una tabla que me dice donde tengoq ue ir a bsucar el registro -> el algoritmo de direccionamitno manda a la tabla -> la tabala es un paso intermedio de direccionamiento (puedo colocar mas cubetas o zonas segun se me vaya presentando). -> sigue siendo malo con busqueda por intervalos.

Numero de bits que define cuantas entradas tiene la tabla -> profundidad global
Numero de bits que determinan la cubeta, relativo a cada cubeta -> profundida local
El numero de registros almacenable spor cubo suele ser multiplo del tamaño de bloque en disco para aprovechar los paseos.



PAra lo que se hace en hashing dinamico hay que pensarlo bien pues si siemrpe llega al mismo sitio no tiene utilidad.

Es mas dificil que haya hiecos pues son mas aleatorios, pero tambien tienen sus inconvenietes.
